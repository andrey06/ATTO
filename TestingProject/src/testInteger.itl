import com.aestheticintegration.realjava.SimpleProg

function SimpleProg.myTest1(param1: Integer, param2: Boolean): Long {
	if (param1 = 0)
	then 8811  
	else   
		if (param2 = true)   
		then 44 
		else 33
		endif      
	endif  
}   

function SimpleProg.myTest1a(cityTemp: Integer): long { 
	if (cityTemp <> 0)
	then 
		if (cityTemp = null)
		then 0
		else 1
		endif
	else 22  
	endif     
}
/*
function SimpleProg.myTest1c(cityQ: Integer): long { 
	if (cityQ = null)
	then 0
	else
		if (cityQ = 0)
		then 2 
		else 1  
		endif
	endif      
}

function SimpleProg.myTest1b(param1: Float): long {
	if (param1 <= 0.0)
	then Exception("Wrong input for this function")
	else 
		if (param1 < 1.) 
		then Exception("Do not use this input") 
		else 33
		endif
	endif 
}    
*/
//test test13 = SimpleProg.myTest1(0, true): 88
//test test14 = SimpleProg.myTest1(23, false): 33
//test test15 = SimpleProg.myTest1b(1): Exception("Do not use this input")

/* 
let get_value z =
	match z with 
	| Something c -> c
	| Nothing -> 0
;;
	

type boolOpt = None | Some of bool;;
type intOpt = None | Some of int;;
type floatOpt = None | Some of float;;
type stringOpt = None | Some of string;;

type 'a outObjOpt = None | Some of 'a | EXCEPTION of string;;
;;
88888888888

type 'a inpObjOpt = None | Some of 'a
;;
type 'a outObjOpt = None | Some of 'a | EXCEPTION of string;;
;;
let f2z (param:int inpObjOpt): int inpObjOpt =
	if param =   None		
	then Some 11
	else 
		if param =  Some 2
		then Some 22
		else Some 33
;;

let f3b (param:int inpObjOpt) =
	if param =   None		
	then None
	else 
		if param =  Some 2
		then Some 22
		else EXCEPTION "QWER"
;;
let f3d (param:int inpObjOpt) =
	if param =   Some 0		
	then Some 1
	else 
		if param =  Some 2
		then Some 22
		else Some 3
;;
88888888888888888888888888888888888
type 'a objOpt = None | Some of 'a;;

type 'a objExcOpt = None | Some of 'a | EXCEPTION of string;;

let simpleProg_myTest1b (param:int) =
	if param = 0		
	then 88
	else 99
;;
Reflect.Mode.program ();;

let prep_simpleProg_myTest1b  (param:int) = [ ("param", `Int param)];;
let func_name = "simpleProg_myTest1b";;
let rs = Decompose.top func_name;;
Extract.to_file ~signature:(Event.DB.fun_id_of_str func_name) ~filename:"mex.ml" ();;
System.mod_use "mex.ml";;
Caml.List.iter (fun r -> print_string (Decompose.string_of_region r)) rs;;
let tcs = List.map Mex.of_region rs;;

let index_region = 0;;
let params_json = `Assoc (prep_simpleProg_myTest1b ((List.nth tcs index_region).Mex.parQwe));;
Yojson.Basic.pretty_to_channel stdout params_json;; 
 
let index_region = 1;;
let params_json = `Assoc (prep_simpleProg_myTest1 ((List.nth tcs index_region).Mex.param1) ((List.nth tcs index_region).Mex.param2));;
Yojson.Basic.pretty_to_channel stdout params_json;; 

let index_region = 2;;
let params_json = `Assoc (prep_simpleProg_myTest1 ((List.nth tcs index_region).Mex.param1) ((List.nth tcs index_region).Mex.param2));;
Yojson.Basic.pretty_to_channel stdout params_json;; 
*******


List.nth index_region tcs;;
(List.nth index_region tcs).Mex.param;;




* FUNCTION 2
let prep_simpleProg_myTest2 (param21:float) (param22:bool) = [("param21", `Float param21); ("param22", `Bool param22)];;
 
let func_name = "simpleProg_myTest2";;
let rs = Decompose.top func_name;; 

Extract.to_file ~signature:(Event.DB.fun_id_of_str func_name) ~filename:"mex.ml" ()

System.mod_use "mex.ml";;
List.iter (fun r -> print_string (Decompose.string_of_region r)) rs;;
let tcs = List.map Mex.of_region rs;;

let index_region = 0;;
let params_json = `Assoc (prep_simpleProg_myTest2 ((List.nth tcs index_region).Mex.param21) ((List.nth tcs index_region).Mex.param22));;
Yojson.Basic.pretty_to_channel stdout params_json;; 

let index_region = 1;;
let params_json = `Assoc (prep_simpleProg_myTest2 ((List.nth tcs index_region).Mex.param21) ((List.nth tcs index_region).Mex.param22));;
Yojson.Basic.pretty_to_channel stdout params_json;; 

let index_region = 2;;
let params_json = `Assoc (prep_simpleProg_myTest2 ((List.nth tcs index_region).Mex.param21) ((List.nth tcs index_region).Mex.param22));;
Yojson.Basic.pretty_to_channel stdout params_json;; 
*******  

 


let params_to_json (param1: int) (param2: bool) = `Assoc prep_to_json;;
let params_to_json2  = `Assoc prep_to_json;;


let zz = params_json |> member "param1";;
* 
// Function 1
let params_to_json (param1: int) (param2: bool) = `Assoc [("param1", `Int param1); ("param2", `Bool param2)];;
let rs1 = Decompose.top "simpleProg_myTest1";; 
Extract.to_file ~signature:"simpleProg_myTest1" ~filename:"mex.ml" ();;
System.mod_use "mex.ml";;
List.iter (fun r -> print_string (Decompose.string_of_region r)) rs1;;

let tcs1 = List.map Mex.of_region rs1;;

let params_json = params_to_json ((List.nth tcs1 0).Mex.param1) ((List.nth tcs1 0).Mex.param2);;
Yojson.Basic.pretty_to_channel stdout params_json;; 

let params_json2 = params_to_json2 ((List.nth tcs1 0).Mex.param1) ((List.nth tcs1 0).Mex.param2);;
Yojson.Basic.pretty_to_channel stdout params_json2;; 

 

let params_json = params_to_json ((List.nth tcs1 1).Mex.param1) ((List.nth tcs1 1).Mex.param2);;
Yojson.Basic.pretty_to_channel stdout params_json;; 
let params_json = params_to_json ((List.nth tcs1 2).Mex.param1) ((List.nth tcs1 2).Mex.param2);;
Yojson.Basic.pretty_to_channel stdout params_json;; 


*******
let params_to_json params = `Assoc params;;
let p3 = params_to_json (prep_to_json ((List.nth tcs1 1).Mex.param1) ((List.nth tcs1 1).Mex.param2));;
Yojson.Basic.pretty_to_channel stdout p3;; 


let p4 = `Assoc (prep_to_json ((List.nth tcs1 1).Mex.param1) ((List.nth tcs1 1).Mex.param2));;
Yojson.Basic.pretty_to_channel stdout p4;; 




*******************************************

 
Yojson.Basic.pretty_to_channel stdout person3;;

let j22 (t1:t)= `Assoc [("x", `Int t1.x); ("y", `Int t1.y)];;  
let t1 :t = {x=11;y=31};;
let w22 = j22 t1;;
Yojson.Basic.pretty_to_channel stdout w22;;


*******
 


docker run -it eu.gcr.io/imandra-core-env/imandra-pure-bin

let simpleProg_myTest1 (cityTemp : int): int =
	if cityTemp  = 0 
	then 88
	else 44
;;
simpleProg_myTest1 0
;; 
simpleProg_myTest1 23
;;

let rs = Decompose.top "simpleProg_myTest1";; 
Reflect.Mode.program ();;
Extract.to_file ~signature:"simpleProg_myTest1" ~filename:"mex.ml" ();;
System.mod_use "mex.ml";;

List.iter (fun r -> print_string (Decompose.string_of_region r)) rs;;
let tcs = List.map Mex.of_region rs;;



docker run -it eu.gcr.io/imandra-core-env/imandra-pure-bin

exception App_exception of string;;
let f (param: int): int =
	if param  = 0 
	then raise (App_exception "Wrong input for this function")
	else 44
;;
let rs = Decompose.top "f";; 
Reflect.Mode.program ();;
Extract.to_file ~signature:"f" ~filename:"mex.ml" ();;
System.mod_use "mex.ml";;
List.iter (fun r -> print_string (Decompose.string_of_region r)) rs;;
let tcs = List.map Mex.of_region rs;;

let g (param: int): int =
	if param  = 0 
	then raise Division_by_zero
	else 44
;;
let rs2 = Decompose.top "g";; 


***********************************

module Ex = struct
  type t = {
    x : int;
    y : int;
  }
  let f (x1 : t) (x2: int) =
    if x1.x > 10 then x1.x
    else if x2 > 10 then x1.y
    else x2
end
;;

let rs = Decompose.top "f";; 
Reflect.Mode.program ();;
Extract.to_file ~signature:"f" ~filename:"mex.ml" ();;
System.mod_use "mex.ml";;

// Constraints and Invariants
List.iter (fun r -> print_string (Decompose.string_of_region r)) rs;;

// Test-cases
let tcs = List.map Mex.of_region rs;;

// Call function for each region
qwe {Mex.???}
**************
*/

/*
docker run -it -v /Users/AndreyIgnatovich/runtime-EclipseXtext/Test1/printers:/home/imandra/temp eu.gcr.io/imandra-core-env/imandra_bin

let simpleProg_myTest1 (cityTemp: int): int =
	if cityTemp  = 0 
	then 88
	else 44
;;
simpleProg_myTest1(0)
;;
simpleProg_myTest1(23) 
;; 
   
:load_ocaml /home/imandra/temp/prInteger_myTest1.ml;;
 
:testgen simpleProg_myTest1 with_printer prInteger_myTest1;;
   
   
   Extract.to_file ~signature:"qwe" ~filename:"mex.ml" ();;

module Ex = struct
  type t = {
    x : int;
    y : int;
  }
  let f (x1 : t) (x2: int) =
    if x1.x > 10 then x1.x
    else if x2 > 10 then x1.y
    else x2
end
;;

let rs = Decompose.top "Ex.f";; 
Reflect.Mode.program ();;
Extract.to_file ~signature:"Ex.f" ~filename:"mex.ml" ();;
System.mod_use "mex.ml";;

List.iter (fun r -> print_string (Decompose.string_of_region r)) rs;;
let tcs = List.map Mex.of_region rs;;


type int_res = Bad_input of int | Funny_input of int | Good_input of int;;

type int_res4 = None | Some of int;;
type integer = None | Some of int;;
type intOpt = None | Some of int;;
 
*******************************
type intOpt = None | Some of int;;

let g (param1:int_opt) =
	if param1 = None		
	then 1
	else 2
;;

let i1 = 4;;
let w1 par1 = match par1 with
	| 2 -> 22
	| 4 -> 44
	| par1 -> 55;;

type boolOpt = None | Some of bool;;
type intOpt = None | Some of int;;
type floatOpt = None | Some of float;;
type stringOpt = None | Some of string;;

let w2 par1 = match par1 with
	| None -> 0
	| Some 2 -> 22
	| Some 4 -> 44
	| Some par1 -> 55;;

let f4 (param:intOpt) =
	if param = None		
	then NO_EXN_INT 88
	else 
		if param = Some 1
		then NO_EXN_INT 99
		else EXCEPTION "qwe"
;;
let f4a (param:int) =
	if param = 13		
	then NO_EXN_INT 88
	else 
		if param =  1
		then NO_EXN_INT 99
		else EXCEPTION "qwe"
;;
let f5 (param:intOpt) =
	if param = None		
	then None
	else 
		if param = Some 1
		then NO_EXN_INT 99
		else EXCEPTION "qwe"
;;
let f6 (param:int): int =
	if param = 13		
	then None
	else 
		if param =  1
		then NO_EXN_INT 99
		else EXCEPTION "qwe"
;;
let get_value (z: 'a objOpt) =
	match z with 
	| Something c -> c
	| Nothing -> raise (Exception "Wrong");;
;;

open Time;;
let log_entry maybe_time message =
    let time =
      match maybe_time with
      | Some x -> x
      | None -> Time.now ()
    in
    Time.to_sec_string time ^ " -- " ^ message
;;
let f1 (cityTemp:int objOpt) =
	if get_value cityTemp 0 <> 0		
	then if cityTemp = Nothing	 
	then Something 0
	else Something 1
	else Exception "WWW33333RRONG"
;;

let f4 (cityTemp:int objExcOpt objOpt) =
	if get_value3 cityTemp <> 0		
	then if cityTemp = Nothing	
	then Something 0 
	else Something 1
	else Exception "WWW33333RRONG"
;;
let get_value5 (z: 'a objOpt): ('a objExcOpt) =
      match z with
      | Something x -> x
      | Nothing -> Exception "Wrong"
;;
let get_value6 (z: 'a objOpt) =
      match z with
      | Something x -> x
      | Nothing -> Nothing
;;



*/ 
    