/**
 * generated by Xtext 2.12.0
 */
package com.aestheticintegration.atto.validation;

import com.aestheticintegration.atto.itlDsl.BoolExpression;
import com.aestheticintegration.atto.itlDsl.DataType;
import com.aestheticintegration.atto.itlDsl.DataTypeInstance;
import com.aestheticintegration.atto.itlDsl.DefDataType;
import com.aestheticintegration.atto.itlDsl.DefDataValue;
import com.aestheticintegration.atto.itlDsl.DefFunction;
import com.aestheticintegration.atto.itlDsl.DefTest;
import com.aestheticintegration.atto.itlDsl.InputParam;
import com.aestheticintegration.atto.itlDsl.ItlDslPackage;
import com.aestheticintegration.atto.itlDsl.Literal;
import com.aestheticintegration.atto.itlDsl.Model;
import com.aestheticintegration.atto.itlDsl.OutputExpression;
import com.aestheticintegration.atto.itlDsl.Primary;
import com.aestheticintegration.atto.itlDsl.Primitives;
import com.aestheticintegration.atto.itlDsl.impl.DefFunctionImpl;
import com.aestheticintegration.atto.itlDsl.impl.ExpOrIfStatementImpl;
import com.aestheticintegration.atto.util.AttoUtil;
import com.aestheticintegration.atto.validation.AbstractItlDslValidator;
import com.google.common.base.Objects;
import java.util.List;
import java.util.function.Predicate;
import javax.inject.Inject;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Conversions;

/**
 * This class contains custom validation rules.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#validation
 */
@SuppressWarnings("all")
public class ItlDslValidator extends AbstractItlDslValidator {
  private static String OCAML_OPTION = "Opt";
  
  @Inject
  private AttoUtil attoUtil;
  
  @Check
  public void checkUniqueness(final DefDataType defDataType) {
    EList<DefDataType> datatypes = this.attoUtil.getAllDefDataTypes(defDataType);
    final Predicate<DefDataType> _function = (DefDataType it) -> {
      String _name = it.getName();
      String _name_1 = defDataType.getName();
      return Objects.equal(_name, _name_1);
    };
    long qty = datatypes.stream().filter(_function).count();
    if ((qty != 1)) {
      this.error("The datatype is not unique", null, ItlDslPackage.DATA_TYPE_VALUE);
    }
    EList<InputParam> fields = defDataType.getFields();
    int _size = fields.size();
    boolean _lessThan = (1 < _size);
    if (_lessThan) {
      for (final InputParam inputParam : fields) {
        final Predicate<InputParam> _function_1 = (InputParam it) -> {
          String _name = it.getName();
          String _name_1 = inputParam.getName();
          return Objects.equal(_name, _name_1);
        };
        long _count = fields.stream().filter(_function_1).count();
        boolean _lessThan_1 = (1 < _count);
        if (_lessThan_1) {
          String _name = inputParam.getName();
          String _plus = ("The field \'" + _name);
          String _plus_1 = (_plus + "\' is not unique");
          this.error(_plus_1, null, ItlDslPackage.INPUT_PARAM__NAME);
        }
      }
    }
  }
  
  @Check
  public void checkUniqueness(final DefDataValue defDataValue) {
    String _name = defDataValue.getName();
    boolean _tripleEquals = (_name == null);
    if (_tripleEquals) {
      return;
    }
    EList<DefDataValue> datavalues = this.attoUtil.getAllDefDataValues(defDataValue);
    final Predicate<DefDataValue> _function = (DefDataValue it) -> {
      String _name_1 = it.getName();
      String _name_2 = defDataValue.getName();
      return Objects.equal(_name_1, _name_2);
    };
    long qty = datavalues.stream().filter(_function).count();
    if ((qty != 1)) {
      this.error("The datavalue is not unique", null, ItlDslPackage.DATA_TYPE_VALUE);
    }
  }
  
  @Check
  public Object checkUniqueness(final DefFunction defFunction) {
    return null;
  }
  
  @Check
  public void checkUniqueness(final DefTest defTest) {
    EList<DefTest> tests = this.attoUtil.getAllDefTests(defTest);
    final Predicate<DefTest> _function = (DefTest it) -> {
      String _name = it.getName();
      String _name_1 = defTest.getName();
      return Objects.equal(_name, _name_1);
    };
    long qty = tests.stream().filter(_function).count();
    if ((qty != 1)) {
      this.error("The test is not unique", null, ItlDslPackage.DEF_TEST);
    }
  }
  
  @Check
  public void checDataValueWithDataType(final DataTypeInstance dataTypeInstance) {
    EList<InputParam> dataTypeFields = dataTypeInstance.getDefDataType().getFields();
    int _size = dataTypeFields.size();
    int _size_1 = dataTypeInstance.getLiterals().size();
    boolean _lessThan = (_size < _size_1);
    if (_lessThan) {
      this.error("Too many arguments in this datavalue", null, ItlDslPackage.DATA_TYPE_INSTANCE);
      return;
    }
    for (int index = 0; (index < dataTypeInstance.getLiterals().size()); index++) {
      {
        String dataTypeType = this.attoUtil.convertDataTypeToPrimitive(dataTypeFields.get(index).getInputDataType());
        String dataTypeTypeOpt = dataTypeType;
        boolean _endsWith = dataTypeType.endsWith(ItlDslValidator.OCAML_OPTION);
        boolean _not = (!_endsWith);
        if (_not) {
          dataTypeTypeOpt = (dataTypeType + ItlDslValidator.OCAML_OPTION);
        }
        String primaryType = this.attoUtil.convertLiteralToPrimitive(dataTypeInstance.getLiterals().get(index));
        String primaryTypeOpt = primaryType;
        boolean _endsWith_1 = primaryType.endsWith(ItlDslValidator.OCAML_OPTION);
        boolean _not_1 = (!_endsWith_1);
        if (_not_1) {
          primaryTypeOpt = (primaryType + ItlDslValidator.OCAML_OPTION);
        }
        boolean _notEquals = (!Objects.equal(dataTypeTypeOpt, primaryTypeOpt));
        if (_notEquals) {
          this.error("Wrong type of the arguments in this datavalue", null, ItlDslPackage.DATA_TYPE_INSTANCE);
        }
      }
    }
  }
  
  @Check
  public CharSequence checkFunctionSig(final DefTest test) {
    StringConcatenation _builder = new StringConcatenation();
    _builder.append("\t");
    _builder.newLine();
    return _builder;
  }
  
  @Check
  public void checkBooleanExpressionWithInputDataTypeGreetingStartsWithCapital(final BoolExpression boolExpression) {
    String literalLeftType = this.findInputParamMap(boolExpression, boolExpression.getLiteralLeft());
    if (((boolExpression.getLiteralRight() == null) && 
      (!Objects.equal(literalLeftType, Primitives.BOOL.getLiteral())))) {
      this.error("Wrong type. The left part of the literal should be a boolean", null, ItlDslPackage.BOOL_EXPRESSION);
      return;
    }
    String literalRightType = this.findInputParamMap(boolExpression, boolExpression.getLiteralRight());
    if (((literalLeftType == null) || (literalRightType == null))) {
      return;
    }
    String literalLeftTypeOpt = literalLeftType;
    boolean _endsWith = literalLeftType.endsWith(ItlDslValidator.OCAML_OPTION);
    boolean _not = (!_endsWith);
    if (_not) {
      literalLeftTypeOpt = (literalLeftType + ItlDslValidator.OCAML_OPTION);
    }
    String literalRightTypeOpt = literalRightType;
    boolean _endsWith_1 = literalRightType.endsWith(ItlDslValidator.OCAML_OPTION);
    boolean _not_1 = (!_endsWith_1);
    if (_not_1) {
      literalRightTypeOpt = (literalRightType + ItlDslValidator.OCAML_OPTION);
    }
    if (((!literalLeftTypeOpt.equals(literalRightTypeOpt)) && 
      (!(Objects.equal(literalRightType, Primitives.NULL.getLiteral()) && literalLeftType.endsWith(ItlDslValidator.OCAML_OPTION))))) {
      this.error("Wrong type. The data types are not the same", null, ItlDslPackage.BOOL_EXPRESSION);
    }
    return;
  }
  
  @Check
  public void checkOutputExpressionWithOutputDataType(final OutputExpression outputExpression) {
    EObject _eContainer = outputExpression.eContainer();
    boolean _not = (!(_eContainer instanceof ExpOrIfStatementImpl));
    if (_not) {
      return;
    }
    DataType funcDateType = this.findFuncReturnDataType(outputExpression);
    String primFuncReturnType = this.attoUtil.convertDataTypeToPrimitive(funcDateType);
    String primFuncReturnTypeOpt = primFuncReturnType;
    boolean _endsWith = primFuncReturnType.endsWith(ItlDslValidator.OCAML_OPTION);
    boolean _not_1 = (!_endsWith);
    if (_not_1) {
      primFuncReturnTypeOpt = (primFuncReturnType + ItlDslValidator.OCAML_OPTION);
    }
    String expressReturnType = this.attoUtil.convertOutputExpressionToPrimitive(outputExpression);
    String expressReturnTypeOpt = expressReturnType;
    boolean _endsWith_1 = expressReturnType.endsWith(ItlDslValidator.OCAML_OPTION);
    boolean _not_2 = (!_endsWith_1);
    if (_not_2) {
      expressReturnTypeOpt = (expressReturnType + ItlDslValidator.OCAML_OPTION);
    }
    if ((((!Objects.equal(expressReturnTypeOpt, primFuncReturnTypeOpt)) && 
      (!Objects.equal(expressReturnType, Primitives.EXCEPTION.getLiteral()))) && 
      (!(Objects.equal(expressReturnType, Primitives.NULL.getLiteral()) && primFuncReturnType.endsWith(ItlDslValidator.OCAML_OPTION))))) {
      String funcReturnType = this.attoUtil.convertDataTypeToString(funcDateType);
      this.error((("Wrong type. It should be \'" + funcReturnType) + "\'"), null, ItlDslPackage.OUTPUT_EXPRESSION);
    }
    return;
  }
  
  private String findInputParamMap(final BoolExpression boolExpression, final Literal literal) {
    String literalType = null;
    EObject eContainer = boolExpression.eContainer();
    String _variable = literal.getVariable();
    boolean _tripleNotEquals = (_variable != null);
    if (_tripleNotEquals) {
      while (((eContainer != null) && (!(eContainer instanceof DefFunctionImpl)))) {
        eContainer = eContainer.eContainer();
      }
      if ((eContainer != null)) {
        DefFunction defFunc = ((DefFunction) eContainer);
        String[] partVariable = literal.getVariable().split("\\.");
        EList<InputParam> _inputParams = defFunc.getInputParams();
        for (final InputParam inputParam : _inputParams) {
          boolean _equals = inputParam.getName().equals(partVariable[0]);
          if (_equals) {
            literalType = this.attoUtil.convertDataTypeToPrimitive(inputParam.getInputDataType());
            final String[] _converted_partVariable = (String[])partVariable;
            int _size = ((List<String>)Conversions.doWrapArray(_converted_partVariable)).size();
            boolean _lessThan = (1 < _size);
            if (_lessThan) {
              EObject _eContainer = defFunc.eContainer();
              Model model = ((Model) _eContainer);
              EList<DefDataType> _datatypes = model.getDatatypes();
              for (final DefDataType defDataType : _datatypes) {
                String _name = defDataType.getName();
                boolean _equals_1 = Objects.equal(_name, literalType);
                if (_equals_1) {
                  EList<InputParam> _fields = defDataType.getFields();
                  for (final InputParam inputParam2 : _fields) {
                    boolean _equals_2 = inputParam2.getName().equals(partVariable[1]);
                    if (_equals_2) {
                      literalType = this.attoUtil.convertDataTypeToPrimitive(inputParam2.getInputDataType());
                    }
                  }
                }
              }
            }
          }
        }
      }
      if ((literalType == null)) {
        String _variable_1 = literal.getVariable();
        String _plus = ("The variable \'" + _variable_1);
        String _plus_1 = (_plus + "\' is unknown");
        this.error(_plus_1, null, ItlDslPackage.LITERAL__VARIABLE);
        return literalType;
      }
    }
    Primary _primary = literal.getPrimary();
    boolean _tripleNotEquals_1 = (_primary != null);
    if (_tripleNotEquals_1) {
      literalType = this.attoUtil.convertPrimaryToPrimitive(literal.getPrimary());
    }
    return literalType;
  }
  
  private DataType findFuncReturnDataType(final OutputExpression outputExpression) {
    DataType funcReturnType = null;
    EObject eContainer = outputExpression.eContainer();
    while (((eContainer != null) && (!(eContainer instanceof DefFunctionImpl)))) {
      eContainer = eContainer.eContainer();
    }
    if ((eContainer != null)) {
      funcReturnType = ((DefFunctionImpl) eContainer).getOutputDataType();
    }
    return funcReturnType;
  }
}
